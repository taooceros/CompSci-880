\documentclass{article}
\usepackage[utf8]{inputenc}
% 页眉
\usepackage{fancyhdr}
% 页面布局
\usepackage[
  papersize={8.5in,11in},
  a4paper,
  bindingoffset=0.2in,
  left=1.2in,
  right=1.2in,
  top=1in,
  bottom=1in,
  footskip=.25in,
  headheight=14pt,
]{geometry}
% 预定义颜色
\usepackage[dvipsnames]{xcolor}
% 超链接
\usepackage[
  colorlinks,
  linkcolor = BrickRed,
  citecolor = Green,
  filecolor = Mulberry,
  urlcolor  = NavyBlue,
  menucolor = BrickRed,
  runcolor  = Mulberry,
]{hyperref}
% 页脚
\usepackage[
  perpage,
  hang,
  flushmargin,
]{footmisc}
% 多行页脚
\usepackage{footnotebackref}
% 图像
\usepackage{graphicx}
% 控制章节标题格式
\usepackage{sectsty}
% Letter Spacing
% 详见 https://tex.stackexchange.com/questions/522106/is-there-a-way-to-get-wider-spacing-between-the-letters
\usepackage{soul} 
% 控制章节标题格式
\usepackage[explicit]{titlesec}
% 控制 TOC 目录格式
\usepackage{titletoc}
% 控制列表格式
\usepackage[shortlabels]{enumitem}
% 彩色框 - 本模板用于定义定理，定义，例子的框图样式
% 详见 https://tex.stackexchange.com/questions/562753/how-to-make-a-colour-box-in-these-3-different-ways
\usepackage{tcolorbox}
% Tikz 绘图
\usepackage{tikz}
% Tikz 交换图绘图
\usepackage{tikz-cd}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}

% RSFS 字体
% 详解 https://tug.org/FontCatalogue/ralphsmithsformalscript/
\usepackage{mathrsfs}
% 数学
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amsmath}
% 划线抵消删除符号
\usepackage{cancel}

% 浮动体，提供 [H] `PUT IT HERE` 选项
\usepackage{float}
% 提供更细粒度的浮动体 Caption 控制
\usepackage{caption}
% 提供并排浮动体的子 Caption 控制（左右排列的图片使用不同的 Caption）
\usepackage{subcaption}
% 提供多列的文章排版
\usepackage{multicol}
% 提供更细粒度的表格宽度控制
\usepackage{tabularx}
% 希腊字母
\usepackage{upgreek}
% 修改字体 / 数学字符的大小
\usepackage{relsize}

% 注释块
\usepackage{verbatim}

% 用于生成测试文本， 可以删除
\usepackage{blindtext}

% 图像资源路径
\graphicspath{{images/}}


% % 代码块
% \renewcommand{\theFancyVerbLine}{%
%   \ttfamily {%
%     \oldstylenums{\arabic{FancyVerbLine}}
%   }
% }

% % 字体
% \setmainfont{New York Small Regular}[
%   ItalicFont = New York Small Regular Italic
% ]
% \setsansfont{SF Pro Text}[
%   ItalicFont = New York Small Regular Italic
% ]

% \newcommand{\emoji}[1]{
%   {\setmainfont{Apple Color Emoji}[Renderer=Harfbuzz]{#1}}
% }

% \setmonofont[
%   ItalicFont     = JetBrains Mono Italic,
%   BoldFont       = JetBrains Mono Bold,
%   BoldItalicFont = JetBrains Mono Bold Italic,
%   Contextuals    = Alternate,
% ]{JetBrains Mono}

% \newfontfamily\lmmono{Latin Modern Mono}
% \newfontfamily\bsans{SF Pro Text Bold}
% \newfontfamily\displaysans{SF Pro Display}

% % 设置所有章节标题字体为非衬线字体
% \allsectionsfont{\displaysans}

\sodef\chapterso{}{.5em}{2em}{2em}

% 设置章节标题样式
\titleformat{\chapter}[display]
{\bfseries} %format
{\textsf{\textbf{\large\chapterso{\MakeUppercase\chaptertitlename}\hspace{1.1em}\thechapter}}} %label
{1.5em} %sep 
{{\textbf{\huge#1}}\bfseries} %before-code

\titlespacing*{\chapter}{0pt}{-30pt}{40pt}

% 设置 TOC 样式
\titlecontents{chapter}
[1.5em]
{\sf}
{\bsans Chapter \thecontentslabel. }
{\huge}
{\mdseries\titlerule*[0.75em]{.}\bfseries \thecontentspage} 
[\addvspace{.5pc}]

\titlecontents{section}
[2.5em]
{\sf}
{\thecontentslabel. }
{\huge}
{\mdseries\titlerule*[0.75em]{.}\bfseries \thecontentspage} 
[\addvspace{.5pc}]

\titlecontents{subsection}
[3.5em]
{\sf}
{\thecontentslabel. }
{\huge}
{\mdseries\titlerule*[0.75em]{.}\bfseries \thecontentspage} 
[\addvspace{.5pc}]

\titlecontents{subsubsection}
[3.5em]
{\sf}
{\thecontentslabel. }
{\huge}
{\mdseries\titlerule*[0.75em]{.}\bfseries \thecontentspage} 
[\addvspace{.5pc}]

% 链接样式
\urlstyle{same}
\let\oldurl\url

% 彩色定理 / 例子 / 定义环境
\definecolor{theorembg}{HTML}{F2F2F9}
\definecolor{theoremfr}{HTML}{00007B}
\definecolor{examplebg}{HTML}{F8E5D5}
\definecolor{examplefr}{HTML}{FA893F}
\definecolor{exampleti}{HTML}{2A7F7F}
\definecolor{definitbg}{HTML}{DEFFD4}
\definecolor{definitfr}{HTML}{60AD49}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{remark}{Remark}
\newtheorem{exercise}{Exercise}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{conjecture}{Conjecture}
\newtheorem{assumption}{Assumption}
\newtheorem{notation}{Notation}
\newtheorem{claim}{Claim}
\newtheorem{observation}{Observation}
\newtheorem{fact}{Fact}
\newtheorem{solution}{Solution}
\newtheorem{convention}{Convention}


\tcbuselibrary{theorems,skins,hooks}

\newtcbtheorem[number within=section]{Theorem}{Theorem}
{%
   enhanced
  ,colback = theorembg
  ,frame hidden
  ,boxrule = 0sp
  ,borderline west = {2pt}{0pt}{theoremfr}
  ,sharp corners
  ,detach title
  ,before upper = \tcbtitle\par\smallskip
  ,coltitle = theoremfr
  ,fonttitle = \bfseries\sffamily
  ,description font = \mdseries
  ,terminator sign none
  ,separator sign none
}
{th}

\newtcbtheorem[number within=section]{Example}{Example}
{%
   enhanced
  ,colback = examplebg
  ,frame hidden
  ,boxrule = 0sp
  ,borderline west = {2pt}{0pt}{examplefr}
  ,sharp corners
  ,detach title
  ,before upper = \tcbtitle\par\smallskip
  ,coltitle = examplefr
  ,fonttitle = \bfseries\sffamily
  ,description font = \mdseries
  ,terminator sign none
  ,separator sign none
}
{ex}


\newtcbtheorem[number within=section]{Definition}{Definition}
{%
   enhanced
  ,colback = definitbg
  ,frame hidden
  ,boxrule = 0sp
  ,borderline west = {2pt}{0pt}{definitfr}
  ,sharp corners
  ,detach title
  ,before upper = \tcbtitle\par\smallskip
  ,coltitle = definitfr
  ,fonttitle = \bfseries\sffamily
  ,description font = \mdseries
  ,terminator sign none
  ,separator sign none
}
{def}

%% Backref
\makeatletter
\LetLtxMacro{\BHFN@Old@footnotemark}{\@footnotemark}

\makeatother


\author{Hongtao Zhang}
\date{\today}
\title{Comp Sci 880 HW1}


% --- 预定义快捷方式 ---

\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\suchthat}{\textnormal{ such that }}
\newcommand{\for}{\textnormal{ for }}
\newcommand{\where}{\textnormal{ where }}
\newcommand{\by}{\textnormal{ by }}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\T}{\mathcal{T}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\card}{\textnormal{card}}

\newcommand{\Mmn}{\M_{m,n}}
\newcommand{\FF}[2]{\F^{#1 \times #2}}
\newcommand{\RR}[2]{\R^{#1 \times #2}}
\newcommand{\CC}[2]{\C^{#1 \times #2}}
\newcommand{\seq}[1]{\{#1_i\}_{i=1}^{\infty}}
\newcommand{\trace}{\operatorname{tr}}
\newcommand{\rsa}{\rightsquigarrow}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\spann}[1]{\operatorname{span}(#1)}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\vol}{\operatorname{vol}}
\newcommand{\cis}{\operatorname{cis}}
\newcommand{\Sym}{\operatorname{Sym}}
% partial qed
\newcommand{\qedp}{\hfill $\square$}

\DeclarePairedDelimiter\bra{\langle}{\rvert}
\DeclarePairedDelimiter\ket{\lvert}{\rangle}

\newcommand{\mat}[1]{\begin{bmatrix} #1 \end{bmatrix}}
\newcommand{\vmat}[1]{\begin{vmatrix} #1 \end{vmatrix}}
\newcommand{\pmat}[1]{\begin{pmatrix} #1 \end{pmatrix}}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


\begin{document}

% 标题
\maketitle

% 目录
{
  \hypersetup{linkcolor=black}
  \tableofcontents
}




% --- 正文 ---
\pagebreak
\section{Question 1}

What we want to do is to split the real part and the imaginary part, and then do calculation with only real entry
but resulting complex effect.

Firstly we need to split the amplitude into two part. It is easy to check that the RHS also have 2-norm 1.

\begin{equation}\label{eq_1}
  \begin{pmatrix}
    a+ci \\
    b+di \\
    0    \\
    0    \\
  \end{pmatrix} \to
  \begin{pmatrix}
    a \\
    b \\
    c \\
    d \\
  \end{pmatrix}
\end{equation}

(Based on Piazza post, we can assume this transformation is given)

Then we can do the calculation with only real entry, and then combine the result back.

For any Complex Unitary $U_c= A+Bi$, we can represent it with a real unitary matrix $U$ as

\[
  U = \begin{pmatrix}
    A & -B \\
    B & A  \\
  \end{pmatrix}
\]

Then its action on the state vector $
  \begin{pmatrix}
    a \\
    b \\
    c \\
    d \\
  \end{pmatrix}$ is exactly the same as the action of $U$ on the state vector $
  \begin{pmatrix}
    a + ci \\
    b + di \\
    0      \\
    0      \\
  \end{pmatrix}$ with the transformation \eqref{eq_1}.

The thing left to check is that the matrix $U$ is unitary.

\begin{proof}
  \begin{align*}
    U U^{*} & =
    \begin{pmatrix}
      A & -B \\
      B & A  \\
    \end{pmatrix}
    \begin{pmatrix}
      A^*  & B^* \\
      -B^* & A^* \\
    \end{pmatrix}                           \\
            & = \begin{pmatrix}
                  A A^* + B B^* & AB^* - BA^*            \\
                  BA^* - AB^*            & A A^* + BB^* \\
                \end{pmatrix}
  \end{align*}

  We know that matrix $U_c=A+Bi$ is unitary,
  so $U_c U_c^*=I=(A+Bi)(A+Bi)^T$

  \[
    \begin{aligned}
      (A+Bi)(A+Bi)^* & = (A+Bi)(A^*-B^*i)               \\
                     & = AA^* - AB^*i + BA^*i - B^*i Bi \\
                     & = AA^* + BB^* - AB^*i + BA^*i                   \\
                     & = I
    \end{aligned}
  \]

  Because $I$ doesn't have complex entries, so \(AB^*i+BA^*i=0\), which means $AA^* + BB^*$.
  Therefore, $U U^*=I$.
  Therefore, $A A^* + B B^* = I$, which means $U$ is unitary.
\end{proof}

Finally, if we do a measurement on the first m qubits when the
ancillary qubits are in state $\ket{0}$, we will get the same result
for the complex gates on the first $m$ qubits. (\textbf{Need check})

\pagebreak

\section{Question 2}

For Deutsch-Jozsa, we firstly apply the Hadamard gate on all qubits,
then apply the oracle,
and then apply the Hadamard gate on the first qubit.

Then we can view the Hadamard gate as the transformation
to the amplitude axis, and the phase kickback as the transformation
to the Flip and Reflection, and the other Hadamard gate as the transformation
back to original basis.

\subsection{Balanced Function}

\tikzpicture

\coordinate (A) at (-3,3);
\coordinate (B) at (3,3);
\coordinate (C) at (3,-3);
\coordinate (D) at (-3,-3);

\draw[help lines, color=gray!30, dashed] (-4,-4.9) grid (4.9,4.9);
\draw[->, thick] ([shift=({-1,0})]A)--([shift=({1,0})]A) node[right]{$\ket{0^n}$};
\draw[->, thick] ([shift=({0,-1})]A)--([shift=({0,1})]A) node[above]{$\ket{\alpha}$};
\draw[black] (A) circle (1);
\draw[red, ->, very thick] ([shift=({0,0})]A)--([shift=({1,0})]A);


\draw[->, thick] ([shift=({2.5,0})]A)--([shift=({4,0})]A) node[right]{} node[above, midway]{$H$};

\draw[->, thick] ([shift=({-1,0})]B)--([shift=({1,0})]B) node[right]{$\ket{C}$};
\draw[->, thick] ([shift=({0,-1})]B)--([shift=({0,1})]B) node[above]{$\ket{B}$};
\draw[black] (B) circle (1);

\draw[red, ->, very thick] ([shift=({0,0})]B)--([shift=({1,0})]B);


\draw[->, thick] ([shift=({0,-2})]B)--([shift=({0,-3.5})]B) node[right]{} node[right, midway]{$U_b$};


\draw[->, thick] ([shift=({-1,0})]C)--([shift=({1,0})]C) node[right]{$\ket{C}$};
\draw[->, thick] ([shift=({0,-1})]C)--([shift=({0,1})]C) node[above]{$\ket{B}$};
\draw[black] (C) circle (1);

\draw[->, red, very thick] (C) -- ([shift=({0,1})]C);
\draw[->, red, very thick] (C) -- ([shift=({0,-1})]C);

\draw[->, thick] ([shift=({-2,0})]C)--([shift=({-3.5,0})]C) node[right]{} node[above, midway]{$H$};

\draw[->, thick] ([shift=({-1,0})]D)--([shift=({1,0})]D) node[right]{$\ket{0^n}$};
\draw[->, thick] ([shift=({0,-1})]D)--([shift=({0,1})]D) node[above]{$\ket{\alpha}$};
\draw[black] (D) circle (1);

\draw[->, red, very thick] (D) -- ([shift=({0,1})]D);
\draw[->, red, very thick] (D) -- ([shift=({0,-1})]D);

\endtikzpicture

\subsection{Constant function}

\tikzpicture

\coordinate (A) at (-3,3);
\coordinate (B) at (3,3);
\coordinate (C) at (3,-3);
\coordinate (D) at (-3,-3);

\draw[help lines, color=gray!30, dashed] (-4,-4.9) grid (4.9,4.9);

\draw[->, thick] ([shift=({-1,0})]A)--([shift=({1,0})]A) node[right]{$\ket{0^n}$};
\draw[->, thick] ([shift=({0,-1})]A)--([shift=({0,1})]A) node[above]{$\ket{\alpha}$};
\draw[black] (A) circle (1);
\draw[red, ->, very thick] ([shift=({0,0})]A)--([shift=({1,0})]A);


\draw[->, thick] ([shift=({2.5,0})]A)--([shift=({4,0})]A) node[right]{} node[above, midway]{$H$};

\draw[->, thick] ([shift=({-1,0})]B)--([shift=({1,0})]B) node[right]{$\ket{C}$};
\draw[->, thick] ([shift=({0,-1})]B)--([shift=({0,1})]B) node[above]{$\ket{B}$};
\draw[black] (B) circle (1);

\draw[red, ->, very thick] ([shift=({0,0})]B)--([shift=({1,0})]B);

\draw[->, thick] ([shift=({0,-2})]B)--([shift=({0,-3.5})]B) node[right]{} node[right, midway]{$U_c$};


\draw[->, thick] ([shift=({-1,0})]C)--([shift=({1,0})]C) node[right]{$\ket{C}$};
\draw[->, thick] ([shift=({0,-1})]C)--([shift=({0,1})]C) node[above]{$\ket{B}$};
\draw[black] (C) circle (1);

\draw[->, red, very thick] (C) -- ([shift=({1,0})]C);
\draw[->, red, very thick] (C) -- ([shift=({-1,0})]C);

\draw[->, thick] ([shift=({-2,0})]C)--([shift=({-3.5,0})]C) node[right]{} node[above, midway]{$H$};

\draw[->, thick] ([shift=({-1,0})]D)--([shift=({1,0})]D) node[right]{$\ket{0^n}$};
\draw[->, thick] ([shift=({0,-1})]D)--([shift=({0,1})]D) node[above]{$\ket{\alpha}$};
\draw[black] (D) circle (1);

\draw[->, red, very thick] (D) -- ([shift=({1,0})]D);
\draw[->, red, very thick] (D) -- ([shift=({-1,0})]D);

\endtikzpicture

\pagebreak
\section{Question 3}

We can create a controlled version of the black box so make sure the black box transform
to a state that is orthogonal to each other.

In the solution in error elimination, we have learned how to create a
controlled version of the phase kick back black box. We can use this
to create a controlled version of the black box.

The idea is to have a black box that is controlled by an additional ancilla that has
uniform probability between $\ket{0}$ and $\ket{1}$.

Then we can just apply the same analysis as in the Deutsch-Jozsa algorithm.

In this case, the black box will be applied with probability $\frac{1}{3}$.

If the black box is the constant case (i.e. $2^n$0), then the resulting distribution of the modified black box is
identical to the original black box, with up to a global phase change.

If the black box is with $2^{n-2}$ 0 and $2^{n-1}$ 1, then the resulting distribution
of the modified black box will be

\[
  P(x=0) = p + \frac{1}{4} \cdot (1-p) = \frac{1}{3} + \frac{1}{4} \cdot (1-\frac{1}{3}) = \frac{1}{3} + \frac{1}{6} =\frac{1}{2}
\]

Therefore, the resulting distribution is uniform, so the black box is balanced.

Therefore, we can follow the same algorithm as in the Deutsch-Jozsa algorithm.

\pagebreak



\section{Question 4 }

\subsection{}

If two graph are isomorphic, then there must exist some permutation of the vertices
such that \(G_1=G_2\).

On the other hand, it is impossible for two graphs that is not isomorphic to have
any permutation of the vertices that is the same. Therefore, \(\sigma(G_1)\perp \sigma(G_2) \iff G_1 \cong G_2\)

\subsection{}

We know that if two graphs are isomorphic, then there must exist some permutation of the vertices,
so there will exist some destructive interference between the two resulting distribution.

\subsection{}

There exist a way to perform permutation on graph classical doesn't imply that it is possible
to perform superposition of permutation on graph to achieve superposition quantumly in polynomial time.



\pagebreak

\section{Question 5}

\subsection*{First Attempt}

The idea is very simple and like a binary search, each time we chunk half of the range,
and see whether we can find the element in the chunk.

If we found, then the lowest index is in the chunk, otherwise it is in the other chunk.

We will need to do this $n$ time.

Each time Grover search will take $O(\sqrt{N})$ time,
so the final query complexity is $O(n \sqrt{N})$.

However, there will be an issue with the error, where the error will be amplified,
because each time we apply Grover, there will be some error. Therefore, we actually
need to bound the error of every single Grover search to be \(\frac{1}{2n}\), which
might require additional logarithmic factor of \(n\).

\subsection*{Second Attempt}

Notice that we didn't actually exploit the fact of the Grover search,
which it might give a uniformly sample from the set of solutions.

Based on Markov inequality, with probability \(\frac{1}{2}\), we will be in the bound
\(2\mathbb{E} [X]\), therefore, as long as we can have the expected runtime be within
the required bound, with high probability, we will not exceed some constant times the bound.

Therefore, we will only consider expected bound in the following analysis.

The idea is an improvement of the previous algorithm, where we will use the fact that
Grover search will give a uniformly sample from the set of solutions.

On the first round, we will do a uniform sampling of the possible from \([0, N]\) to get a point \(x_1\).
Apply \(f\) to the sampled value, and set the bound to be the value of \(f(x)\).
(it is equivalent to do a Grover search that uses the oracle that map everything to \(1\)).

On the second round, we will do a Grover Search with the oracle \(U_f\) that only
map the value that is within the \([0, f(x_1)]\)to \(1\), and the rest to \(0\).
If we find the result equal to \(x_1\), then we succeed (try a few times)
otherwise, we will repeat the process.

We will repeat this process until we find a close enough solution.

For every single run, we expect to remove half of the range, so the expected number of run is \(n\).
Each run we will need \(\sqrt{\frac{N}{t}}\), where t is the size of the range.

Therefore, on average, we can expect the number of query be the following
\[
  \begin{split}
    1 + \sqrt{\frac{N}{\frac{1}{2}N}} + \sqrt{\frac{N}{\frac{1}{4}}N} + \cdots \\
    \approx 1 + \sqrt{2} + \sqrt{4} + \cdots \\
  \end{split}
\]
which is a geometric series, which will converge some constant factor with \(\sqrt{N}\).

We still might need to take care of the accumulated error, which might contribute to a logarithmic factor.

However, we can smartly avoid this error by checking whether the sample from Grover
search is within the range that is actually makes sense. If it is not, then we perform
a Grover search again, which by expectation, we might need on average two trials, which is a constant factor.

The probability of getting \(x_1 = x_*\) is low, which is \(\frac{1}{t}\), where t is the size of the range.

Then, if we just try some constant times, we can have high probability to make sure that we won't stop too early.

The error at the end might not be removed, but it will be bounded by \(\frac{1}{2}\) which is in the allowed range.

\end{document}